[2021 最新 SpringBoot 面试题【40题】 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/406134262#:~:text=2021 最新 SpringBoot 面试题【40题】 1 1. SpringBoot基础 1.1,3.1 如何实现SpringBoot应用程序的安全性？ 为了实现SpringBoot的安全性，我们使用spring-boot-starter-security依赖项，并且必须添加安全配置。 它只需要很少的代码。 ... 4 4. SpringBoot进阶)

[1. 两数之和 题解 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/solution/)

[21. 合并两个有序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-sorted-lists/)

## Java面经

### 面向对象和面向过程的区别：

面向过程的性能比面向对象高， 

面向对象：**易维护，易复用，易扩展**。  面向对象有 封装，继承，多态，可以设计出低耦合的系统，使系统更加零活，便于维护。

面向对象过程比面向对象过程低。

### Java语言有哪些特点：

1.简单易学

2.面向对象

3.可靠，安全

4.支持多线程

5.支持网络编程

### JDK和JRE和JVM分别是什么，有什么区别？

JDK java 开发环境  在bin目录下，jdk有javac.exe，而JRE里没有。

 JRE JAVA 运行环境 ，jvm是运行java字节码的虚拟机。

### 什么是字节码？使用字节码最大的好处是什么？

Java源代码经过虚拟机编译后产生的文件(即.class的文件)，它不面向任何特定的处理器，只面向虚拟机。

Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。

### Java和C++的区别 

都是面向对象的语言 

java不支持指针访问内存，程序内存更加安全

java是单继承，但是接口是支持多继承的

java内存有自动管理机制，自动释放无用内存

### 字符型常量和字符串常量的区别？

1.字符型常量是一个单引号，字符串常量是双引号。

2.字符型常量相当于一个整型值，字符串常量代表一个地址值。

### 重载和重写的区别

1. 重载：方法名必须相同，参数类型不同，个数不同，顺序不同。

2. 重写：子类对父类的允许访问的方法进行重新编写。  抛出异常范围要小于父类，访问修饰符要大于父类构造方法不能被重写

### String SpringBuffer 和StringBuilder  的区别

String默认是以常量形式存在的，且由final修饰，因此在线程池中是线程安全的，因此每个String被创建好，他就不会发生变化，但它的执行速度是最差的。

String Buffer :StringBuffer 相对于StringBulider效率相对于低一点，StringBuffer更多考虑的是多线程，在进行字符串操作的情况下，它使用了synchronize关键字，对方法进行了同步处理，因此，StringBuffer适合在多线程中使用。 

StringBuilder 线程安全 （没有考虑线程安全问题）：在进行多线程对一个对象同时产生操作时，会产生预期之外的结果，对于StringBuilder来说，执行效率虽然高，但是因为线程不安全，所以不建议在多线程环境中对一个StringBuilder对象进行操作，因此StringBuilder适用于单线程环境下的大量字符串操作。

### 接口和抽象类有什么区别？

接口不可以有实现  默认public    抽象类中可以有非抽象方法

一个类可实现多个接口，但只能实现一个抽象类。接口本身可以extends关键字扩展多个接口

### 构造方法有哪些特性？

1. 名字与类名相同
2. 没有返回值
3. 生成类的对象自动执行，无需调用

### @Autowired 和@Resource 的区别？

@Autowired默认按照类型自动装配，在容器中查找匹配的Bean，当且仅有一个匹配的Bean时，Spring将其注入@Autowired标注的变量中

@Resource 默认按照名称进行匹配，当找不到名称匹配则按照类型进行匹配。

### SpringMVC 工作流程

1.客户端发送请求，请求DispatcherServlet.

2.DispatcherServlet根据信息调用HandlerMapping，解析对应的Hander（controller）

3.解析到对应的Hander  由HandlerAdapter适配器处理。

4.然后处理的对应的业务逻辑

5.会返回ModelAndView对象，Model是返回的对象，View是逻辑上的对象

6.ViewResolver会根据逻辑View查找实际的View

把View返回给请求端

设计模式是什么？为什么要学习和使用设计模式？

工厂设计模式：通过BeanFactory，ApplicationContext创建Bean对象

代理设计模式：Spring AOP功能的实现

单例模式：Spring 中Bean默认是单例的

包装器设计模式：

观察者模式

设计模式是指在软件开发中经常遇到的一些重复性问题，通过对这些问题的总结、抽象、归纳和提炼，得到的一些解决问题的通用方案。学习和使用设计模式可以帮助开发人员提高代码的可重用性、可维护性、可扩展性和可读性，从而提高开发效率和代码质量。

1. 工厂模式：当需要创建多种具有相同特征的对象时，使用工厂模式可以将对象的创建与业务逻辑分离，降低代码的耦合度。 例如，在电商平台上，不同种类的商品都需要进行库存管理和订单管理，可以使用工厂模式来创建对应的库存管理器和订单管理器。
2. 单例模式：当需要确保系统中某个类只有一个实例时，可以使用单例模式，保证全局唯一性，避免资源的浪费。 例如，在 Web 应用中，有时需要保证所有请求都使用同一个数据库连接，可以使用单例模式来实现数据库连接池。
3. 观察者模式：当一个对象的状态发生改变需要通知其他对象时，可以使用观察者模式，将对象的状态与业务逻辑分离，提高系统的灵活性和可扩展性。 例如，在多人在线游戏中，玩家的行为会影响其他玩家的状态，可以使用观察者模式来实现游戏中的事件处理和状态同步。
4. 策略模式：当需要在运行时根据不同的情况采用不同的算法时，可以使用策略模式，将算法与业务逻辑分离，提高代码的可维护性和扩展性。 例如，在电商平台上，可以使用策略模式来实现不同的促销策略，例如满减、打折等。

###  Spring管理事务的方式有哪几种？

编程时事务（不推荐）

声明式事务，在配置文件中配置

### 什么是数据库事务？ ACID?

数据库事务是一种机制，一个操作序列。

数据库具有4个特性

**原子性**：事务是一个原子操作，要么全部提交，要么全部回滚。

**一致性**：事务在结束时，数据必须保持一致状态。在事务执行期间，数据可能处于中间状态，但事务完成时，必须保持一致状态。

**隔离性**：数据库设计必须保证事务相互隔离，不会相互干扰。隔离级别不同，会影响数据的并发性和一致性。比如出现脏读，不可重复读

**持久性**：一旦事务提交，其所修改必须永久保存在数据库中。即使系统发生故障或宕机，数据也保持不变。

这4个事务统称为ACID

四种隔离级别：

第一种隔离级别：Read uncommitted(读未提交)：解决了更新丢失，但还可能出现脏读。

第二种隔离机制：Read committed(读提取)：解决了更新丢失和脏读问题。

第三章隔离机制：Repeatable read(可重复读)：解决了更新丢失、脏读、不可重复读、但是还会出现幻读

第四种隔离级别：Serializable(可序化)：解决了更新丢失、脏读、不可重复读、幻读(虚读)

### 进程和线程的区别

一个进程可以有多个线程，多个线程共享一个进程的堆和方法区资源， 但每个线程有自己的程序计数器，虚拟机栈，和本地方法栈。

### 计算机网络七层模型和各自的作用?

计算机七层模型把网络通信协议分为7个层次的标准模型，这个模型被称作OSI模型。

我们在浏览器传输地址时，将电信号转化为比特流，在数据链路层将比特流转化为

**物理层**：主要是物理媒介传输比特流，如光缆，光纤，无线电波等。

**数据链路层**：主要把数据分成数据帧进行传输，并对错误进行检测和纠正。数据链路层还负责物理地址的分配，流量控制，接口的规范等。

**网络层**：主要是网络中的传输，包括路由选择，分组转发，数据报文的封装，网络层还处理数据包的寻址和控制流量。

**运输层**：主要负责数据传输的可靠性和流量控制等，同时包括分段，组装，连接建立和断开等功能。运输层最重要的两个协议：TCP和UDP

**会话层：**主要负责建立，管理和终止会话，提供会话控制和同步等服务。

**表示层**：主要负责数据格式转换，加密解密，压缩解压等服务。

**应用层**：提供各种服务和应用程序，如电子协议，文件传输，远程登陆。

### 三次握手

客户端发送SYN标识的数据包，---一次握手给服务端

服务端发送SYN/ACK标志的数据包--二次握手给客户端

客户端发送ACK标志的数据包--三次握手给服务端

### 四次挥手

客户端发送一个FIN,用来关闭客户端到服务端的数据传送

服务端-接收到这个FIN，他发送一个ACK,确认序号为1，和SYN一样，一个FIN将占用一个序号

服务器关闭与客户端的连接，并发送一个FIN给客户端

客户端发回ACK报文确认

### 什么是yaml？ yaml有哪些优点？

1.yaml中有配置的顺序性，在某些场合，配置更为重要。

2.yaml中支持数组，可以配置基本对象

3.相对于properties，yaml配置更加简洁。

### Redis基本数据类型

1.String

2.list

3.hash

4.set

5.sorted set

### 介绍Redis

Redis是基于C语言开发的数据库，Redis是存储在内存中，是内存数据库，读写速度快，所以Redis广泛用于缓存方向

Reids除了做缓存 ，可以用来做分布式锁，甚至是消息队列

Redis提供了多种数据类型来提供不同的业务场景，Redis还支持事务，持久化，Lua脚本，多种集群方案

### 缓存数据流程是怎样的？

1. 用户请求缓存如果存在直接返回
2. 缓存不存在去查看数据库是否存在
3. 数据库中存在的话直接更新缓存
4. 数据库不存在直接返回空数据

### ArrayList?

ArrayList是一个数组列表，相当于动态数组。它继承了AbstractList，实现了List，RandomAccess，Cloneable，java.io.Serializable这些接口。

ArrayList 不是线程安全的，建议在单线程中使用，多线程建议使用Vector或者CopyOnWriteArrayList。

### HashMap?

HashMap共有四个构造函数，1.初始化数组大小，加载因子。2.初始化数组大小。3.无参。4.HashMap结构。

### HashMap的底层数据结构是什么？

在JDK1.7中，由数组+链表组成，数组时HashMap的主体。链表则是解决Hash冲突而存在的。

在JDK1.8中，由数组+链表+红黑树组成，当链表过长时，会影响HashMap的性能。

### HashMap 中 key 的存储索引是怎么计算的？

首先根据Key的值计算hashcode的值，然后根据hashcode计算出hash值，最后通过hash计算存储的位置。

### 并发和并行有什么区别？同步和异步有什么区别？

**并发**：指的是系统中同时存在多个正在执行的任务，并且这些任务之间可能会相互影响。并发通常用来处理多个任务共享资源的情况。在单核 CPU 上，多个任务会轮流使用 CPU 时间片，表现为看似同时执行的情况，但实际上只有一个任务正在执行。

**并行：**指的是系统中同时存在多个并且相互独立的任务，并且这些任务可以在多个处理器上同时执行，真正意义上的同时处理多个任务。

**同步**：指的是程序按照代码的顺序执行，一行一行地执行，直到当前行执行完成后才能继续执行下一行。同步通常会阻塞调用者，直到任务完成才能返回。

**异步**：指的是程序在执行某个任务时，不会一直等待任务完成，而是继续执行下一行代码，当任务完成后再进行相应的处理。异步通常不会阻塞调用者，可以提高系统的并发性能。

### 为什么要使用多线程？

1. 线程是程序执行的最小单位，线程的切换和调度远小于进程，另外，多个CPU时代意味着多个线程同时进行，减少了进程上下文的开销。

### 使用多线程可能会带来什么问题？

1.内存泄漏

2.上下文切换

3.死锁

### 说说线程的生命周期和状态？

线程创建后处于**NEW** (创建)状态，调用start()方法开始运行，线程这时候处于（ready）可运行状态，可运行状态的线程获得了CPU时间片，后就处于Running（运行）状态。

### 什么是上下文切换？



### 什么是线程死锁？ 如何避免死锁？

多个线程同时被阻塞，他们中的一个或多个在等待某个资源被释放。由于线程被无限阻塞，程序不能正常被终止。

死锁的原因.

1.互斥条件：该资源任一一个时刻只有一个线程占用。

2.请求与保持请求： 一个进程因请求资源而阻塞，对以或资源保持不变。

3.不剥夺条件： 线程在使用过程中不能被其他线程强请剥夺，只有自己使用完才能被释放

4.循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。

### 说说sleep()和wait()方法区别和共同点？

最主要的区别：  sleep（）方法没有释放锁，wait（）方法释放了锁。

两者都可以暂停线程的执行。

wait()通常是线程之间的交互  sleep（）通常是暂停执行。

###  为什么我们调用start（）方法时会执行run（）方法，而我们不能直接调用RUN()方法

调用start（）方法时可启动线程并使线程进入就绪状态，执行RUN()方法不会以多线程的方式去执行。

### 对synchronized的理解

synchronized 解决的是多个线程之间资源的同步性，synchronized关键字可以保证被它修饰的方法或代码块在任意时刻只能由一个线程来执行。

### 说说synchronized关键字和volatile关键字的区别。

1.volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好，但是volatile关键字只能用于变量而synchronized关键字可以修饰方法及代码块。

2.volatile关键字可以保证数据的可见性，但不能保证数据的原子性，synchronized两者都可以保证。

3.vilatile关键字主要解决变量在多个线程之间的可见性，而synchronized关键字解决的是多个线程之间访问资源的同步性。

### 为什么要使用线程池

1.降低资源的消耗

2.提高响应速度

3.提高线程的可管理性

### DNS解析过程





### 输⼊⼀个URL到浏览器，整体流程

1.根据域名 进行DNS域名解析，

2.拿到解析的Ip地址，建立TCP连接

3.像IP地址，发送HTTP请求

4.服务器处理请求

5.返回响应结果

6.关闭TCP连接

7.浏览器解析HTML

8.浏览器布局渲染

### 知道哪些Java锁





###  设计模式了解吗？⼏⼤类型？

1.创建型模式： 工厂方法模式，抽象工程模式，单例模式，建造者模式，原型模式

2.结构性模式：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式

3.行为型模式：策略模式，观察者模式，迭代子模式，命令模式，状态模式

工厂模式： 我们在创建对象是 不会对客户端暴露创建逻辑，并通过一个共同的接口来指向新创建的对象。

### 什么是 IOC，简单讲一下 Spring IOC 的实现机制？

IOC 控制反转， 一种设计思想。  AOP面向切面编程，

IOC的主要实现方式有两种：依赖查找，依赖注入。

AOP一般用于签名校验，参数校验，日志记录，事务控制，权限管理，性能统计，异常处理等。

Spring的核心组件就是Bean工厂(BeanFactory)，Bean工厂使用控制反转(IOC)模式来降低程序代码之间的耦合度，并提供了面向切面编程（AOP）的实现。

### 静态代理和动态代理的区别？

代理分为动态代理和静态代理，静态代理将代理类和被代理类耦合在一起，实现起来时非常不方便，需要大量编码。

AOP的宗旨就是实现无耦合的增强，动态代理就是AOP思想的实现方法之一，无耦合的方法对代码无侵入性，可以很方便的实现代码的增强，如果想要代码增加一些通用的增强，可以选择动态代理。

### 索引的优缺点

1. 索引大大减少了服务器需要扫描的数据量，而大大加快数据检索的速度。
2. 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。
3. 缺点：如果非常小的表，大部分情况下简单的全表扫描更高效。

### 创建索引准测？应该创建索引的列

1. 经常需要搜索的列，可以加快搜索结果
2. 在经常用在连接(join)上的列，这些列主要是一外键，可以加快连接的速度。
3. 在经常使用where子句上面创建索引，加快条件判断速度。
4. 在经常需要排序的列上创建索引，因为索引已经排序，这样可以利用索引的排序，加快排序查询时间。

### 不该创建索引的列？

1. 对于那些很少数据值或者重复值多的列不应该增加索引。
2. 对于那些定义为text，image和bit数据类型的列不应该增加索引，这些列数据量要么相当大，要么取值很少。
3. 当该列修改性能要求远远高于检索性能时，不应该创建索引。（修改性能和检索性能时相互矛盾的）

###  几种常见的异常

1. NullPointerException 空指针引用异常
2. ClassCastException 类型强制转换异常
3. IndexOutBoundsException 下标越界异常
4. NumberFormatExpection 数字格式异常
5. SecurityExpection 安全异常

### linux常用命令

1. htop
2. echo：在终端显示定义的文本
3. cat：用于从终端直接创建，查看和连接文件
4. ps： 查看当前shell会话正在运行的进程。
5. kill：当一个程序没有相应，可以通过PID（进程ID）杀死进程
6. which：输出shell命令的完整路径。
7. tail：于cat类似，tail打印文件内容时有一个主要警告，它只输出最后几行，默认是10行

### 数据库三范式

1. 列不可再分
2. 属性完全依赖于主键
3. 属性不依赖于其它非主属性  属性直接依赖于主键

### MySQL 事务的并发问题

1. **脏读**：事务A读取了事务B的更新事务，然后B回滚，那么A读取的数据是脏数据。
2. 不可重复读：事务A多次读取同一数据，事务B在事务A读取过程中，对数据进行了更新并提交，导致事务A多次读取同一数据，结果导致数据不一致。
3. 幻读：幻读解决了不可重复读，保证了同一个事务里，查询的结果都是事务开始的状态（一致性）。

### 事务的隔离级别

  默认：repeatable-read

### 事务的四大特性

1. 原子性：要么全部成功，要么全部回滚。
2. 一致性：事务开始和结束后，数据库的完整性约束没有被破坏。
3. 隔离性：多个并发事务要隔离。
4. 持久性：一但事务被提交，那么数据库中的数据的改变是永恒的。

### MySQL 存储引擎

InnoDB：提供事务，支持事务。

锁级别：支持事务和行级锁，行锁提高了多用户并发操作的新能，但是InooDB的行锁，只是在WHERE的主键是有效的。

### 聚集索引和非聚集索引的区别？

1. 聚集索引一个表只能有一个，而非聚集索引一个表会有多个
2. 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续。
3. 聚集索引插入数据时速度要慢（时间花在了物理存储的排序上，要找到位置才能插入），查询比非聚集索引要快。

### 非关系型数据库和关系型数据库的区别？

关系型数据库：

1. 相对于理解：相对于其他模型（网状，层次）更容易理解

2. 使用方便：统一通过SQL语言，操作数据库更方便

3. 易于维护：都是表结构，格式统一

   缺点：

   1. 扩展性差，表结构固定

非关系型数据库：

1. 格式灵活：存储格式以Key-value 文档等格式

2. 性能优越：非关系型数据库可以使用硬盘或者随机存储器作为载体

3. 成本低：基本都是开源的，部署快

   缺点：

   1. 不支持SQL
   2. 无事务处理机制，无法回滚
   3. 数据结构导致复杂查询不易实现

### 使用explain优化sql和索引？

[(47条消息) （Mysql优化学习02）Explain详解与索引最佳实践_ZGOOD9527的博客-CSDN博客](https://blog.csdn.net/a250029634/article/details/128858250)

### 什么是 内连接、外连接、交叉连接、笛卡尔积等？

1. 内连接（inner join）：取得两张表满足存在连接匹配关系的记录。（左表 jion 右表 on  匹配条件）

### char和varchar的使用场景？

1. char 长度固定，每条数据占用登长字节空间，适合身份证，手机号码等

2. varchar 可变长度，可以设置最大长度，适合长度可变的情况

3. text 是不可设置长度，当不知道属性最大长度时，适合用text

    查询速度：  char最快，varchar次之，text最慢

### MySQL性能优化

1. EXPLAIN你的SELECT查询
2. 当只要1行数据时使用LIMIT 1
3. 为搜索字段建索引
4. 避免select *
5. 为每一个表设置一个id
6. 尽可能的使用not null
7. 固定长度的表会更快
8. 垂直分割
9. 拆分打的delete 或insert 语句
10. 越小的列会越快
11. 选择正确的存储引擎  qps  接口的qps在300左右，但是考虑到这个接口只有读操作，没有增删改操作，所以我将这张表的存储引擎从Innodb改为了MyISAM，接口的qps提升到了1500。

### 缓存三大问题以及解决方案 缓存穿透，缓存击穿，缓存雪崩

[牛逼，三句话搞懂 Redis 缓存穿透、击穿、雪崩！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/335353729)

1. **缓存穿透：**查询的数据不存在    
   1.  缓存空值  key值校验
   2. 如布隆筛选器ref 分布式布隆过滤器
2. **缓存击穿：**缓存过期，伴随大量对该Key的请求
   1.  互斥锁
   2. 热点数据永不过期
   3. 熔断降级
3. **缓存雪崩：**同一时间大量的key过期
   1. 热点数据不过期
   2. 随机分散过期时间

### Redis 如何保证原子性的？

1. Redis 是单线程，所以Redis API提供的也是原子性的
2. 在我们业务中常常有先get 后set的业务常见，在并发下会导致数据不一致的情况。
   1. 使用incr，decr，setnx等原子操作
   2. 客户端加锁
   3. 使用Lua脚本实现CAS操作

### Redis 有哪些应用场景？

1. String：缓存，限流，分布式锁，计数器，分布式Session等
2. Hash：用户信息，用户主页访问量，组合查询等
3. List：简单队列，关注列表时间轴
4. Set：赞，踩，标签等
5. ZSet：排行榜，好友关系链表

### Redis 实现链表有哪些特性？

1. 链表是一种常见的数据结构，C语言内部没有内置这种数据结构，所以Redis自己构建了链表的实现
   1. **双端：**链表具有前置节点和后置节点的引用，获取这两个节点的时间复杂度都是O1
   2. **无环：**
   3. **带长度计算器**
   4. **多态**

### Redis的数据过期策略是什么？

1. expire key time -这是最常见的方法
2. setex（String key，int seconds，String value）--字符串独有的方式

### 如何实现分布式锁？

1. 互斥性：任何时刻，只有一个客户端能持有锁

2. 锁超时释放：持有锁超时时，可以释放，防止不必要的资源浪费，也可以防止死锁

3. 可重入性：一个线程如果获取了锁之后，可以再次请求加锁。

4. 高性能和高可用：加锁和解锁需要开销尽可能低，同时也要保证高可用，避免分布式锁失效

5. 安全锁：锁只能被持有的客户端删除，不能被其他用户端删除

   ![image-20230207145216514](E:\笔记\图片\image-20230207145216514.png)

   ​	RedLock加锁机制：

   1. 按顺序向集群中所有master节点请求加锁，
   2. 根据设置超时时间来判断，是不是要跳过该master节点
   3. 如果大于或等于半数节点（N/2+1）加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功
   4. 如果获取锁失败，解锁。

### JDK 动态代理和 CGLIB 动态代理的区别是什么？

Java动态代理是利用**反射机制**生成一个代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理，核心是实现InvocationHandler接口，使用invoke()方法面向切面的处理，调用应用的通知。

而 **CGLIB**动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成的子类来处理。核心是MethodInterceptor接口，使用intercept()方法进行面向切面的处理，调用相应的通知。

JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理。

### MySQL 日志有了解过吗？binlog、redolog、undolog 分别有什么作用?





### Spring 框架是什么？使用 Spring 框架有哪些好处？

Spring是一个开源框架，它是解决企业开发的复杂性而创作的，框架的主要优势就是分层架构，封层架构允许使用者选择使用哪一个组件，同时为J2EE应用程序开发提供集成的框架。Spring的核心就是控制反转(IOC)和面向切面(AOP)，简单来说，Spring是一个分层的轻量级开源框架。

优点：

1. 方便解耦，简单开发

   通过Spring提供的Ioc容器，我们可以将对象之间的依赖关系交给Spring进行控制，避免硬编码造成的过度程序耦合，有了Spring，用户不必再为单例类，模式类，等这些很底层的需求编写代码，可以更专注于上层的应用。

2. AOP编程的支持 

    通过Spring提供的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。

3. 声明式事务的支持

   在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方法进行事务的管理，提高开发效率和质量。

4. 方便程序测试

    在Spring里，测试不再是昂贵的操作，有Spring对Junit4支持，可以通过注解方便的测试Spring程序。

### 什么是分布式？为什么需要分布式？

分布式是指将一个大型系统分割成多个子系统，每个子系统都可以独立运行，但又可以通过网络协同工作，共同完成系统的功能。每个子系统可以运行在不同的物理机器上，也可以运行在不同的进程或线程中。

### Mysql中索引是怎么实现的？B 树和 B+ 树的区别，为什么 MySQL 要用 B+ 树？

MySQL 中的索引是通过 B+ 树实现的。B+ 树是一种多叉树，它可以将数据按照一定的顺序组织起来，从而提高查询效率。

B+ 树与 B 树的区别在于，B+ 树的所有数据都存储在叶子节点上，而非叶子节点只存储索引，这样可以提高数据查询效率。B+ 树的叶子节点之间使用指针相连，这样可以实现区间查找，也就是说，可以快速定位某个区间内的数据。

MySQL 之所以采用 B+ 树作为索引的实现方式，主要是因为 B+ 树具有以下优点：

1. 能够支持高效的范围查找和排序。
2. 叶子节点之间使用指针相连，能够支持高效的区间查询。
3. B+ 树具有较高的数据密度，可以减少磁盘 I/O 次数，提高查询效率。
4. B+ 树对于插入和删除操作也比较高效。

### 什么是消息队列？消息队列有哪些应用场景？

消息队列是一种用于异步通信的机制，用于在不同的应用程序之间传递消息。消息队列通常由消息生产者、消息队列和消息消费者三部分组成。

消息生产者将消息发送到消息队列中，而消息消费者则从消息队列中接收消息。消息队列负责存储和管理消息，确保消息传递的可靠性和稳定性。在实现过程中，消息队列还会提供一些额外的功能，如消息过滤、消息路由、消息持久化等。

消息队列的特点：

1. 异步通信：消息生产者和消息消费者之间采用异步通信模式，发送方无需等待接收方的响应即可继续执行。
2. 解耦合：消息队列可以将消息生产者和消息消费者解耦合，使得它们之间的关系更加灵活。
3. 可靠性：消息队列通常会提供一些保证消息传递可靠性的机制，如消息持久化、重试机制等。
4. 缓冲：消息队列可以缓冲来自多个消息生产者的消息，使得消息消费者可以按照自己的节奏进行消费，从而有效地平衡生产者和消费者之间的处理速度。

消息队列的应用：

1. 异步任务处理：通过将任务发送到消息队列中，异步处理任务，提高系统的并发性能和吞吐量。
2. 解耦合系统：将不同的业务逻辑拆分成不同的服务，通过消息队列实现服务之间的通信，提高系统的可维护性和可扩展性。
3. 流量削峰：将流量通过消息队列分散到不同的服务中，避免单个服务被高并发流量打垮。
4. 日志收集：通过将日志消息发送到消息队列中，将日志收集和分析与业务逻辑解耦合，提高系统的可靠性和可维护性。
5. 应用解耦：将不同的应用程序通过消息队列进行集成，实现应用之间的解耦合和数据交换。

### 什么是三大范式？

第一范式（1NF）：字段（或属性）是不可分割的最小单元，即不会有重复的列，体现原子性

第二范式（2NF）：满足 1NF 前提下，存在一个候选码，非主属性全部依赖该候选码，即存在主键，体现唯一性，专业术语则是消除部分函数依赖

第三范式（3NF）：满足 2NF 前提下，非主属性必须互不依赖，消除传递依赖

### 什么是 BIO、NIO、AIO？

​		BIO，全称 Blocking I/O，也称为同步阻塞 I/O。BIO 是最早的 I/O 模型，它是一种阻塞式的 I/O 模型，即当应用程序调用 I/O 操作时，该操作会一直阻塞线程直到操作完成，这会导致 I/O 性能低下。BIO 适用于连接数较小的场景，例如单线程的服务器模型。

​		NIO，全称 Non-Blocking I/O，也称为同步非阻塞 I/O。NIO 是一种同步非阻塞的 I/O 模型，它的核心是 Selector 和 Channel，利用 Selector 监听多个 Channel 上的事件，当一个 Channel 上的事件到达时，它会被 Selector 转发给注册在这个 Selector 上的其他 Channel，这样可以用一个线程来处理多个请求，提高了 I/O 的效率。NIO 适用于连接数多、连接时间短的场景，例如实时聊天室、在线游戏等。

​		AIO，全称 Asynchronous I/O，也称为异步非阻塞 I/O。AIO 是 JDK1.7 引入的 I/O 模型，它的特点是异步处理 I/O 操作，当操作完成时会通知应用程序，相比于 NIO 的同步非阻塞 I/O，AIO 无需通过轮询操作完成状态，从而提高了 I/O 的效率。AIO 适用于连接数多、连接时间长的场景，例如 HTTP 长连接、文件操作等。

### Spring、SpringMVC、SpringBoot 三者之间是什么关系

1. Spring是一个开源容器框架，可以接管web层，业务层，dao层，持久层的组件，并且可以配置各种bean,和维护bean与bean之间的关系。其核心就是控制反转(IOC),和面向切面(AOP),简单的说就是一个分层的轻量级开源框架。
2. Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。SpringMVC是一种web层mvc框架，用于替代servlet（处理|响应请求，获取表单参数，表单校验等。SpringMVC是一个MVC的开源框架，SpringMVC=struts2+spring，springMVC就相当于是Struts2加上Spring的整合。
3. Springboot是一个微服务框架，延续了spring框架的核心思想IOC和AOP，简化了应用的开发和部署。Spring Boot是为了简化Spring应用的创建、运行、调试、部署等而出现的，使用它可以做到专注于Spring应用的开发，而无需过多关注XML的配置。提供了一堆依赖打包，并已经按照使用习惯解决了依赖问题—>习惯大于约定。

## ArrayList和LinkedList的区别？

 ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；

 底层数据结构： Arraylist 底层使⽤的是 **Object** 数组； LinkedList 底层使⽤的是 **双向链** 表 数据结构

LinkedList 实现了List和Deque接口，一般称为双向链表；ArrayList实现了List接口，动态数组。

 ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留⼀定的容量空间，⽽ LinkedList 的空间花费则体现在它的每⼀个元素都需要消耗⽐ ArrayList 更多的空间 （因为要存放直接后继和直接前驱以及数据）

LinkedList 在插入和删除数据时效率更高，ArrayList 在查找某个 index 的数据时效率更高

LinkedList 比 ArrayList 需要更多的内存；

##  HashMap 和 Hashtable 的区别

HashMap 是⾮线程安全的， HashTable 是线程安全的,因为 HashTable 内 部的⽅法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使⽤ ConcurrentHashMap 吧！）

##  HashMap 和 HashSet区别

HashMap 实现了Map接口，存储键值对，调用put()向map中添加元素， HashMap使用Key计算hashcode

HashTable 实现了Set 接口，仅存储对象，调用add（）方法向Set中添加元素。

## ==与 equals 的区别？

对于基本类型来说，== ⽐的是值是否相等

于引⽤类型来说，== ⽐的是两个引⽤是否指向同⼀个对象地址（两者在内存中存放的地址 （堆内存地址）是否指向同⼀个地⽅）；

对于引⽤类型（包括包装类型）来说，equals 如果没有被重写，对⽐它们的地址是否相等；如果 equals()⽅法被重写（例如 String），则⽐᫾的是地址⾥的内容。

## 20230422

**计划**

1.面经

2.算法

---

- 面经

1.简单说一下HashMap的put过程

hashmap是一个无序的，key-value键值对，key是唯一的，value是存在多个的。若向hashmap中插入key-value值的时候，会存入hashmap内部的数组中。

​	检查key是否存在，若存在，返回key对应的value，若不存在，则将value插入数组内部中

## 20230424

**计划**

1.面经

2.算法

---

- 算法

  爬楼梯



## 20230425

**计划**

1.面经

2.算法

---

- 算法

  合并两个有序链表



